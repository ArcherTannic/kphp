#pragma once

#include <utility>

#include "runtime/exception.h"
#include "runtime/kphp_core.h"

extern const char *last_wait_error;

struct thrown_exception {
  Exception exception;
  thrown_exception() = default;
  explicit thrown_exception(Exception exception) : exception(std::move(exception)) {}
};

class Storage {
private:
  char storage_[sizeof(var)];

  template<class X, class Y, class Tag = typename std::is_convertible<X, Y>::type>
  struct load_implementation_helper;

  void save_exception();

public:

  // this class specializations are generated by kphp compiler

  template<typename T>
  struct tagger {
    static int get_tag();
  };

  template<typename T>
  struct loader {
    using loader_fun = T(*)(char *);
    static loader_fun get_function(int tag __attribute__((unused)));
  };

  int tag;

  Storage();

  template<class T1, class T2>
  void save(const T2 &x);

  void save_void();

  template<class X>
  X load();

  template<class X>
  X load_as();
};


template<class X, class Y>
struct Storage::load_implementation_helper<X, Y, std::false_type> {
  static Y load(char *storage __attribute__((unused))) {
    php_assert(0);      // should be never called in runtime, used just to prevent compilation errors
    return Y();
  }
};

template<class X, class Y>
struct Storage::load_implementation_helper<X, Y, std::true_type> {
  static Y load(char *storage) {
    if (sizeof(X) > sizeof(storage_)) {
      // какие-нибудь длинные tuple'ы (см. save())
      // тогда в storage лежит указатель на выделенную память
      storage = static_cast<char *>(*reinterpret_cast<void **>(storage));
    }
    X *data = reinterpret_cast <X *> (storage);
    Y result = *data;
    data->~X();
    if (sizeof(X) > sizeof(storage_)) {
      dl::deallocate(storage, sizeof(X));
    }
    return result;
  }
};

template<>
struct Storage::load_implementation_helper<void, void, std::true_type> {
  static void load(char *storage __attribute__((unused))) {}
};

template<typename T>
struct Storage::load_implementation_helper<T, void, std::false_type> {
  static void load(char *storage) {
    Storage::load_implementation_helper<T, T>::load(storage);
  }
};

template<class Y>
struct Storage::load_implementation_helper<thrown_exception, Y, std::false_type> {
  static Y load(char *storage __attribute__((unused))) {
    php_assert (CurException.is_null());
    CurException = load_implementation_helper<thrown_exception, thrown_exception>::load(storage).exception;
    return Y();
  }
};

template<>
struct Storage::load_implementation_helper<thrown_exception, void, std::false_type> {
  static void load(char *storage __attribute__((unused))) {
    php_assert (CurException.is_null());
    CurException = load_implementation_helper<thrown_exception, thrown_exception>::load(storage).exception;
  }
};



template<class T1, class T2>
void Storage::save(const T2 &x) {
  if (!CurException.is_null()) {
    save_exception();
  } else {
    if (sizeof(T1) <= sizeof(storage_)) {
      #pragma GCC diagnostic push
      #if __GNUC__ >= 6
        #pragma GCC diagnostic ignored "-Wplacement-new="
      #endif
      new(storage_) T1(x);
      #pragma GCC diagnostic pop
    } else {
      // какие-нибудь длинные tuple'ы, которые не влазят в var
      // для них выделяем память отдельно, а в storage сохраняем указатель
      void *mem = dl::allocate(sizeof(T1));
      new(mem) T1(x);
      *reinterpret_cast<void **>(storage_) = mem;
    }

    tag = tagger<T1>::get_tag();
  }
}

template<class X>
X Storage::load() {
  php_assert (tag != 0);
  if (tag == tagger<thrown_exception>::get_tag()) {
    tag = 0;
    return load_implementation_helper<thrown_exception, X>::load(storage_);
  }

  php_assert(tag == tagger<X>::get_tag());
  tag = 0;
  return load_implementation_helper<X, X>::load(storage_);
}


template<class X>
X Storage::load_as() {
  php_assert (tag != 0);

  int tag_save = tag;
  tag = 0;
  return (loader<X>::get_function(tag_save))(storage_);
}
