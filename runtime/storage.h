#pragma once

#include <utility>

#include "runtime/exception.h"
#include "runtime/kphp_core.h"

extern const char *last_wait_error;

struct thrown_exception {
  Exception exception;
  thrown_exception() = default;
  explicit thrown_exception(Exception exception) : exception(std::move(exception)) {}
};

template<size_t limit>
union small_obect_ptr {
  char storage_[limit];
  void *storage_ptr;

  template <typename T, typename ...Args>
  std::enable_if_t<sizeof(T) <= limit, T*> emplace(Args&& ...args) {
    return new (storage_) T(std::forward<Args>(args)...);
  }
  template <typename T>
  std::enable_if_t<sizeof(T) <= limit, T*> get() {
    return reinterpret_cast<T*>(storage_);
  }
  template <typename T>
  std::enable_if_t<sizeof(T) <= limit> destroy() {
    get<T>()->~T();
  }

  template <typename T, typename ...Args>
  std::enable_if_t<limit < sizeof(T), T*> emplace(Args&& ...args) {
    storage_ptr = dl::allocate(sizeof(T));
    return new (storage_ptr) T(std::forward<Args>(args)...);
  }
  template <typename T>
  std::enable_if_t<limit < sizeof(T), T*> get() {
    return static_cast<T*>(storage_ptr);
  }
  template <typename T>
  std::enable_if_t<limit < sizeof(T)> destroy() {
    T *mem = get<T>();
    mem->~T();
    dl::deallocate(mem, sizeof(T));
  }
};

class Storage {
private:
  using storage_ptr = small_obect_ptr<sizeof(var)>;
  storage_ptr storage_;

  template<class X, class Y, class Tag = typename std::is_convertible<X, Y>::type>
  struct load_implementation_helper;

  void save_exception();

public:

  // this class specializations are generated by kphp compiler

  template<typename T>
  struct tagger {
    static int get_tag();
  };

  template<typename T>
  struct loader {
    using loader_fun = T(*)(storage_ptr &);
    static loader_fun get_function(int tag);
  };

  int tag;

  Storage();

  template<class T1, class T2>
  void save(const T2 &x);

  void save_void();

  template<class X>
  X load();

  template<class X>
  X load_as();
};


template<class X, class Y>
struct Storage::load_implementation_helper<X, Y, std::false_type> {
  static Y load(storage_ptr &) {
    php_assert(0);      // should be never called in runtime, used just to prevent compilation errors
    return Y();
  }
};

template<class X, class Y>
struct Storage::load_implementation_helper<X, Y, std::true_type> {
  static Y load(storage_ptr &storage) {
    X *data = storage.get<X>();
    Y result = std::move(*data);
    storage.destroy<X>();
    return result;
  }
};

template<>
struct Storage::load_implementation_helper<void, void, std::true_type> {
  static void load(storage_ptr &) {}
};

template<typename T>
struct Storage::load_implementation_helper<T, void, std::false_type> {
  static void load(storage_ptr &storage) {
    Storage::load_implementation_helper<T, T>::load(storage);
  }
};

template<class Y>
struct Storage::load_implementation_helper<thrown_exception, Y, std::false_type> {
  static Y load(storage_ptr &storage) {
    php_assert (CurException.is_null());
    CurException = load_implementation_helper<thrown_exception, thrown_exception>::load(storage).exception;
    return Y();
  }
};

template<>
struct Storage::load_implementation_helper<thrown_exception, void, std::false_type> {
  static void load(storage_ptr &storage) {
    php_assert (CurException.is_null());
    CurException = load_implementation_helper<thrown_exception, thrown_exception>::load(storage).exception;
  }
};



template<class T1, class T2>
void Storage::save(const T2 &x) {
  if (!CurException.is_null()) {
    save_exception();
  } else {
    storage_.emplace<T1>(x);
    tag = tagger<T1>::get_tag();
  }
}

template<class X>
X Storage::load() {
  php_assert (tag != 0);
  if (tag == tagger<thrown_exception>::get_tag()) {
    tag = 0;
    return load_implementation_helper<thrown_exception, X>::load(storage_);
  }

  php_assert(tag == tagger<X>::get_tag());
  tag = 0;
  return load_implementation_helper<X, X>::load(storage_);
}


template<class X>
X Storage::load_as() {
  php_assert (tag != 0);

  int tag_save = tag;
  tag = 0;
  return (loader<X>::get_function(tag_save))(storage_);
}
